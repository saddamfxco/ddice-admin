<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8">
  <title>Ludo Admin Panel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: "Segoe UI", Arial, sans-serif; background:#f8f9fa; margin:0; padding:0;}
    .wrapper { max-width: 1100px; margin: 22px auto 15px auto; background:#fff; border-radius:14px; box-shadow:0 2px 20px #0001; padding:20px 6px 14px 6px;}
    h2 { color:#3c8dbc; text-align:center; margin:10px 0 10px 0; font-size:19px;}
    table { width:100%; border-collapse:collapse; margin-top:8px;}
    th, td { border:1px solid #d1d5db; padding:6px 4px; text-align:center; font-size:13px;}
    th { background: #f3f6fa; font-size:13px;}
    td.used { background: #ffeaea; color:#d32f2f;}
    td.approved { background: #eaf6ff; color:#1976d2;}
    td.pending { background: #fffde7; color:#bfa100;}
    td.rejected { background: #ffcccc; color:#b71c1c;}
    button { padding:3px 8px; border-radius:5px; border:none; cursor:pointer; font-size:13px;}
    .approve { background: #4caf50; color:#fff;}
    .reset { background: #dd4b39; color:#fff;}
    .paid { background: #4caf50; color:#fff;}
    .winner { color:#4caf50; font-weight:bold;}
    .small { font-size:12px; color:#888;}
    .msg-input { width: 100px; font-size:12px; border:1px solid #bbb; border-radius:3px; padding:2px 3px; margin-right:3px;}
    .msg-btn { background:#1976d2; color:#fff;}
    .msg-btn:disabled {background:#aaa; color:#fff; cursor:not-allowed;}
    #admin-auth {text-align:center; margin:20px 0;}
    #admin-auth input {padding:6px 7px;font-size:14px;}
    .dashboard {margin-top:24px; background:#f9f9fc; border-radius:8px; padding:10px 7px;}
    .dashboard h3 {margin:0 0 8px 0; color:#1d6fa5; font-size:16px;}
    /* --- Notification Box --- */
    #notifBox { background:#ecf6ff; border-radius:10px; margin:24px 0 16px 0; padding:14px 13px; box-shadow:0 2px 10px #1976d209;}
    #notifBox h3 { margin:0 0 8px 0; color:#1976d2; font-size:17px;}
    #notifBox .notif-list { max-height:260px; overflow-y:auto; margin-bottom:8px;}
    #notifBox table { width:100%; font-size:13px;}
    #notifBox th, #notifBox td { border:1px solid #c2d4ea; padding:5px 3px;}
    #notifBox th { background:#d6eaff; }
    #notifBox .all-btns { margin-bottom:7px; }
    #notifBox .msg-input { width:130px; margin-bottom:3px; }
    #notifBox .msg-btn { margin-bottom:3px; }
    @media (max-width: 900px) {
      .wrapper { padding: 3px 1px 5px 1px;}
      table, th, td { font-size: 12px;}
      .msg-input { width: 60px; }
      #notifBox .msg-input { width: 75px; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h2>Withdraw Requests</h2>
    <div id="withdrawTable"></div>

    <h2>Deposit Requests</h2>
    <div id="depositTable"></div>

    <!-- Notification Box for FCM-enabled users -->
    <div id="notifBox" style="display:none;">
      <h3>üîî Notification Panel (FCM Enabled Users)</h3>
      <div class="all-btns">
        <input type="text" id="notif-all-msg" class="msg-input" placeholder="Message for all...">
        <button class="msg-btn" id="sendToAllBtn">Send to ALL</button>
      </div>
      <div class="notif-list">
        <table id="notifUserTable">
          <thead>
            <tr>
              <th>UID</th>
              <th>Name</th>
              <th>Email</th>
              <th>FCM Token</th>
              <th>Send Msg</th>
            </tr>
          </thead>
          <tbody id="notifUserTbody">
          </tbody>
        </table>
      </div>
    </div>

    <div id="admin-auth" style="display:none;">
      <input type="email" id="adminEmail" placeholder="Email">
      <input type="password" id="adminPass" placeholder="Password">
      <button onclick="adminLogin()">Log In</button>
      <div id="authMsg" style="color:#b71c1c;margin-top:6px;font-size:13px;"></div>
    </div>
    <div class="dashboard" id="dashboard"></div>
    <div style="margin-top:22px;color:#b71c1c;text-align:center; font-size:12px;">
      <b>‡¶®‡ßã‡¶ü:</b> ‡¶è‡¶á ‡¶™‡ßá‡¶ú ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®‡ßá ‡¶∞‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§<br>
      Firebase ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶∞‡ßÅ‡¶≤‡¶∏ ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶è‡¶°‡¶Æ‡¶ø‡¶® ‡¶∞‡¶ø‡¶°/‡¶∞‡¶æ‡¶á‡¶ü ‡¶¶‡¶ø‡¶¨‡ßá‡¶®‡•§
    </div>
  </div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script>
    // === CONFIG ===
    const firebaseConfig = {
      apiKey: "AIzaSyDLhqeEYZmHHjYB1TtyZndsQk2wUfIW37k",
      authDomain: "friend-dice-pay.firebaseapp.com",
      databaseURL: "https://friend-dice-pay-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "friend-dice-pay",
      storageBucket: "friend-dice-pay.appspot.com",
      messagingSenderId: "1079545705926",
      appId: "1:1079545705926:web:af3f21bfbad5f866b52ec7"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // === ADMIN ===
    const ADMIN_UID = "JQQMaOYGmNNxkwRO6AvYvbyDWcb2"; // ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶è‡¶°‡¶Æ‡¶ø‡¶® UID ‡¶¶‡¶ø‡¶®
    let isAdmin = false;
    let fcmUsers = {}; // cache FCM-enabled users

    // Local state for real-time tables
    let withdrawMap = {}; // { reqId: {...} }
    let depositMap  = {}; // { depId: {...} }

    let withdrawBootstrapped = false;
    let depositBootstrapped  = false;

    // Helpers
    const getReqTime = (r) => Number(r?.requestedAt || r?.approvedAt || r?.createdAt || 0);
    const byNewest = (a, b) => getReqTime(b) - getReqTime(a);

    // === AUTH ===
    document.getElementById('withdrawTable').innerHTML = `
      <div style="text-align:center;margin:15px 0 0 0;font-size:15px;">
        Checking authentication...
      </div>
    `;
    document.getElementById('depositTable').innerHTML = `
      <div style="text-align:center;margin:15px 0 0 0;font-size:15px;">
        Checking authentication...
      </div>
    `;

    firebase.auth().onAuthStateChanged(function(user) {
      if(user && user.uid === ADMIN_UID) {
        isAdmin = true;
        document.getElementById('admin-auth').style.display = "none";
        loadAdminData();
        document.getElementById('notifBox').style.display = '';
      } else {
        isAdmin = false;
        detachAllListeners();
        clearTables();
        document.getElementById('admin-auth').style.display = "";
        document.getElementById('notifBox').style.display = 'none';
      }
    });

    function adminLogin() {
      const email = document.getElementById('adminEmail').value.trim();
      const pass = document.getElementById('adminPass').value.trim();
      document.getElementById('authMsg').textContent = '';
      firebase.auth().signInWithEmailAndPassword(email, pass).catch(err=>{
        document.getElementById('authMsg').textContent = err.message;
      });
    }

    function clearTables() {
      document.getElementById('withdrawTable').innerHTML = '';
      document.getElementById('depositTable').innerHTML = '';
      document.getElementById('dashboard').innerHTML = '';
      document.getElementById('notifUserTbody').innerHTML = '';
      withdrawMap = {};
      depositMap = {};
      withdrawBootstrapped = false;
      depositBootstrapped = false;
    }

    let withdrawRef, depositRef, usersRef, usersNotifRef;
    function detachAllListeners() {
      if (withdrawRef) withdrawRef.off();
      if (depositRef)  depositRef.off();
      if (usersRef)    usersRef.off();
      if (usersNotifRef) usersNotifRef.off();
    }

    // --- Admin Data Load ---
    function loadAdminData() {
      attachWithdrawListeners();
      attachDepositListeners();

      // Dashboard and FCM users live updates
      usersRef = db.ref('users');
      usersRef.on('value', snap => {
        const users = snap.val() || {};
        renderDashboard(users);
      });

      usersNotifRef = db.ref('users');
      usersNotifRef.on('value', snap => {
        const users = snap.val() || {};
        renderFcmUsers(users);
      });
    }

    // === WITHDRAW: Real-time + De-duplication (keep latest pending per user) ===
    function attachWithdrawListeners() {
      const path = 'withdrawRequests';
      withdrawRef = db.ref(path);

      // Initial load + one-time dedup
      withdrawRef.once('value').then(snap => {
        withdrawMap = {};
        snap.forEach(child => {
          const reqId = child.key;
          const data  = child.val() || {};
          withdrawMap[reqId] = data;
        });
        // Dedup pending requests per UID (keep latest by requestedAt)
        dedupRequestsInDB('withdraw');

        renderWithdrawRequests();
        withdrawBootstrapped = true;

        // Attach real-time listeners
        withdrawRef.on('child_added', s => {
          const id = s.key, data = s.val() || {};
          withdrawMap[id] = data;

          if (withdrawBootstrapped) {
            ensureOnlyLatestPending('withdraw', id, data);
          }
          renderWithdrawRequests();
        });

        withdrawRef.on('child_changed', s => {
          const id = s.key, data = s.val() || {};
          withdrawMap[id] = data;
          renderWithdrawRequests();
        });

        withdrawRef.on('child_removed', s => {
          const id = s.key;
          delete withdrawMap[id];
          renderWithdrawRequests();
        });
      });
    }

    // === DEPOSIT: Real-time + De-duplication (keep latest pending per user) ===
    function attachDepositListeners() {
      const path = 'depositRequests';
      depositRef = db.ref(path);

      // Initial load + one-time dedup
      depositRef.once('value').then(snap => {
        depositMap = {};
        snap.forEach(child => {
          const depId = child.key;
          const data  = child.val() || {};
          depositMap[depId] = data;
        });
        // Dedup pending requests per UID (keep latest by requestedAt)
        dedupRequestsInDB('deposit');

        renderDepositRequests();
        depositBootstrapped = true;

        // Attach real-time listeners
        depositRef.on('child_added', s => {
          const id = s.key, data = s.val() || {};
          depositMap[id] = data;

          if (depositBootstrapped) {
            ensureOnlyLatestPending('deposit', id, data);
          }
          renderDepositRequests();
        });

        depositRef.on('child_changed', s => {
          const id = s.key, data = s.val() || {};
          depositMap[id] = data;
          renderDepositRequests();
        });

        depositRef.on('child_removed', s => {
          const id = s.key;
          delete depositMap[id];
          renderDepositRequests();
        });
      });
    }

    // Remove older PENDING requests per UID from DB, keep latest one
    function dedupRequestsInDB(kind) {
      const isWithdraw = kind === 'withdraw';
      const map = isWithdraw ? withdrawMap : depositMap;
      const path = isWithdraw ? 'withdrawRequests' : 'depositRequests';

      // Group by uid for pending only
      const groups = {};
      Object.entries(map).forEach(([id, r]) => {
        if (!r || !r.uid) return;
        if (String(r.status) !== 'pending') return; // only pending dedup (safe)
        if (!groups[r.uid]) groups[r.uid] = [];
        groups[r.uid].push({ id, data: r });
      });

      Object.values(groups).forEach(list => {
        list.sort((a, b) => getReqTime(b.data) - getReqTime(a.data));
        const keep = list[0]?.id;
        list.slice(1).forEach(item => {
          // Remove older pending
          db.ref(`${path}/${item.id}`).remove().catch(()=>{});
          delete map[item.id];
        });
        // Ensure map keeps the one we decided
        if (keep) {
          // nothing additional
        }
      });
    }

    // Ensure only latest pending exists for this uid after a new add
    function ensureOnlyLatestPending(kind, newId, newData) {
      if (!newData || !newData.uid) return;
      if (String(newData.status) !== 'pending') return;

      const isWithdraw = kind === 'withdraw';
      const map = isWithdraw ? withdrawMap : depositMap;
      const path = isWithdraw ? 'withdrawRequests' : 'depositRequests';

      const siblings = [];
      Object.entries(map).forEach(([id, r]) => {
        if (id === newId) return;
        if (!r) return;
        if (r.uid === newData.uid && String(r.status) === 'pending') {
          siblings.push({ id, data: r });
        }
      });
      if (!siblings.length) return;

      const newTime = getReqTime(newData);
      let keepNew = true;
      siblings.forEach(s => {
        if (getReqTime(s.data) > newTime) keepNew = false;
      });

      if (keepNew) {
        // Remove all siblings (older pending)
        siblings.forEach(s => {
          db.ref(`${path}/${s.id}`).remove().catch(()=>{});
          delete map[s.id];
        });
      } else {
        // New one is older => remove new
        db.ref(`${path}/${newId}`).remove().catch(()=>{});
        delete map[newId];
      }
    }

    // --- Withdraw Requests Table ---
    function renderWithdrawRequests() {
      const rows = Object.entries(withdrawMap).map(([id, r]) => ({ id, ...r }));
      rows.sort(byNewest); // newest first

      let html = `<table>
        <tr>
          <th>UID</th>
          <th>Nickname</th>
          <th>Amount</th>
          <th>Binance UID</th>
          <th>Requested At</th>
          <th>Status</th>
          <th>Approve</th>
          <th>Mark Used</th>
          <th>Send Notification</th>
        </tr>`;

      rows.forEach(r => {
        const statusClass = r.status === 'approved' ? 'approved'
                         : r.status === 'pending' ? 'pending'
                         : r.status === 'used' ? 'used'
                         : r.status === 'rejected' ? 'rejected'
                         : '';
        html += `<tr>
          <td class="small">${r.uid || "-"}</td>
          <td>${r.playerName || "-"}</td>
          <td>${r.amount ? Number(r.amount).toFixed(2) : "0.00"}</td>
          <td>${r.binanceUID || "-"}</td>
          <td>${r.requestedAt ? new Date(r.requestedAt).toLocaleString() : "-"}</td>
          <td class="${statusClass}">${r.status || '-'}</td>
          <td>
            ${r.status === 'pending' ? `<button class="approve" onclick="approveWithdraw('${r.id}', this)">Approve</button>` : ''}
          </td>
          <td>
            ${r.status !== 'used' ? `<button class="reset" onclick="markWithdrawUsed('${r.id}')">Used</button>` : ''}
          </td>
          <td>
            <input type="text" id="notif-msg-${r.id}" class="msg-input" placeholder="Type notification...">
            <button class="msg-btn" onclick="sendNotificationToUser('${r.uid}', 'withdraw', '${r.id}')" title="Send">Send</button>
          </td>
        </tr>`;
      });

      html += `</table>`;
      document.getElementById('withdrawTable').innerHTML = html;
    }

    // --- Deposit Requests Table ---
    function renderDepositRequests() {
      const rows = Object.entries(depositMap).map(([id, r]) => ({ id, ...r }));
      rows.sort(byNewest); // newest first

      let html = `<table>
        <tr>
          <th>UID</th>
          <th>Nickname</th>
          <th>Amount</th>
          <th>Order ID</th>
          <th>Requested At</th>
          <th>Status</th>
          <th>Approve</th>
          <th>Reject</th>
          <th>Send Notification</th>
        </tr>`;

      rows.forEach(d => {
        const statusClass = d.status === 'approved' ? 'approved'
                         : d.status === 'pending' ? 'pending'
                         : d.status === 'rejected' ? 'rejected'
                         : '';
        html += `<tr>
          <td class="small">${d.uid || "-"}</td>
          <td>${d.playerName || "-"}</td>
          <td>${d.amount ? Number(d.amount).toFixed(2) : "0.00"}</td>
          <td>${d.orderId || "-"}</td>
          <td>${d.requestedAt ? new Date(d.requestedAt).toLocaleString() : "-"}</td>
          <td class="${statusClass}">${d.status || '-'}</td>
          <td>
            ${d.status === 'pending' ? `<button class="approve" onclick="approveDeposit('${d.id}', this)">Approve</button>` : ''}
          </td>
          <td>
            ${d.status === 'pending' ? `<button class="reset" onclick="rejectDeposit('${d.id}')">Reject</button>` : ''}
          </td>
          <td>
            <input type="text" id="dep-notif-msg-${d.id}" class="msg-input" placeholder="Type notification...">
            <button class="msg-btn" onclick="sendNotificationToUser('${d.uid}', 'deposit', '${d.id}')" title="Send">Send</button>
          </td>
        </tr>`;
      });

      html += `</table>`;
      document.getElementById('depositTable').innerHTML = html;
    }

    // --- Withdraw Approve Logic: Balance Update (NO lossHistory update!) ---
    window.approveWithdraw = async function(reqId, btn) {
      if (btn) btn.disabled = true;
      try {
        const reqSnap = await db.ref('withdrawRequests/' + reqId).once('value');
        const req = reqSnap.val();
        if (!req || req.status !== "pending") throw new Error("Invalid request or already processed");

        const userRef = db.ref('users/' + req.uid);
        const userSnap = await userRef.once('value');
        const userData = userSnap.val() || {};
        const currBalance = Number(userData.balance || 0);
        const amount = Number(req.amount || 0);
        if (currBalance < amount) throw new Error("Insufficient user balance!");
        const newBalance = Math.max(currBalance - amount, 0.01);

        await userRef.update({ balance: Number(newBalance.toFixed(2)) });

        await db.ref('withdrawRequests/' + reqId).update({
          status: "approved",
          approvedAt: Date.now()
        });
        alert("Withdraw approved & balance updated!");
        // Real-time listeners will re-render
      } catch (err) {
        alert("Error: " + err.message);
      } finally {
        if (btn) btn.disabled = false;
      }
    };

    window.markWithdrawUsed = function(reqId) {
      if (confirm("Mark this withdraw as USED?")) {
        db.ref('withdrawRequests/' + reqId).update({ status: "used" })
        .catch(err => alert('Error: ' + err.message));
        // Real-time listeners will re-render
      }
    };

    // --- Deposit Approve Logic: Balance Update (NO winHistory update!) ---
    window.approveDeposit = async function(depId, btn) {
      if (btn) btn.disabled = true;
      try {
        const depSnap = await db.ref('depositRequests/' + depId).once('value');
        const dep = depSnap.val();
        if (!dep || dep.status !== "pending") throw new Error("Invalid request or already processed");

        const userRef = db.ref('users/' + dep.uid);
        const userSnap = await userRef.once('value');
        const userData = userSnap.val() || {};
        const currBalance = Number(userData.balance || 0);
        const amount = Number(dep.amount || 0);
        const newBalance = Math.max(currBalance + amount, 0.01);

        await userRef.update({ balance: Number(newBalance.toFixed(2)) });

        await db.ref('depositRequests/' + depId).update({
          status: "approved",
          approvedAt: Date.now()
        });
        alert("Deposit approved & balance updated!");
        // Real-time listeners will re-render
      } catch (err) {
        alert("Error: " + err.message);
      } finally {
        if (btn) btn.disabled = false;
      }
    };

    window.rejectDeposit = function(depId) {
      if (confirm("Reject this deposit request?")) {
        db.ref('depositRequests/' + depId).update({ status: "rejected" })
        .catch(err => alert('Error: ' + err.message));
        // Real-time listeners will re-render
      }
    };

    // --- FCM USERS NOTIFICATION PANEL --- //
    function renderFcmUsers(users) {
      let rows = '';
      fcmUsers = {};
      for(const uid in users || {}) {
        const user = users[uid];
        if(user && user.fcmToken) {
          fcmUsers[uid] = { ...user, uid };
          rows += `
            <tr>
              <td>${uid}</td>
              <td>${user.playerName || user.displayName || '-'}</td>
              <td>${user.email || '-'}</td>
              <td style="max-width:110px;overflow-x:auto;">${String(user.fcmToken).slice(0,18)}...<span title="Copy" style="cursor:pointer;color:#1976d2;" onclick="copyFcmToken('${user.fcmToken}')">üìã</span></td>
              <td>
                <input type="text" class="msg-input" id="notif-msg-user-${uid}" placeholder="Message...">
                <button class="msg-btn" onclick="sendPersonalNotif('${uid}')">Send</button>
              </td>
            </tr>
          `;
        }
      }
      document.getElementById('notifUserTbody').innerHTML = rows || `<tr><td colspan="5" style="text-align:center;color:#d32f2f;">No FCM-enabled users found.</td></tr>`;
    }

    // Copy token helper
    window.copyFcmToken = function(token) {
      navigator.clipboard.writeText(token).then(()=>alert('FCM Token copied!'));
    };

    // Send personal notification
    window.sendPersonalNotif = function(uid) {
      const msg = document.getElementById('notif-msg-user-' + uid)?.value?.trim();
      if(!msg) return alert("Message required!");
      const user = fcmUsers[uid];
      if(!user || !user.fcmToken) return alert("No FCM token for this user!");
      sendFcmMsg(user.fcmToken, msg);
    };

    // Send notification to ALL (in sequence)
    document.getElementById('sendToAllBtn').onclick = async function() {
      const msg = document.getElementById('notif-all-msg').value.trim();
      if(!msg) return alert("Enter a message!");
      const keys = Object.keys(fcmUsers || {});
      if(!keys.length) return alert("No FCM-enabled users.");
      if(!confirm("Send this message to all FCM-enabled users?")) return;
      let errors = 0, sent = 0;
      for(const uid of keys) {
        const token = fcmUsers[uid].fcmToken;
        try {
          await sendFcmMsg(token, msg, true);
          sent++;
        } catch(e) {
          errors++;
        }
      }
      alert(`Sent to ${sent} users. Failed: ${errors}`);
    };

    // --- Backend FCM POST logic (localhost:3000/send-fcm) ---
    async function sendFcmMsg(token, msg, silent) {
      const res = await fetch('http://localhost:3000/send-fcm', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ token, msg })
      });
      const data = await res.json().catch(()=>({success:false,error:'Invalid response'}));
      if(!data.success) {
        if(!silent) alert("Failed to send: " + (data.error || "Unknown error"));
        throw new Error(data.error || 'send-failed');
      }
      if(!silent) alert("Notification sent!");
      return true;
    }

    // --- Old notification logic for requests ---
    window.sendNotificationToUser = async function(uid, type, reqId) {
      let msg = "";
      if(type === "deposit") {
        msg = document.getElementById(`dep-notif-msg-${reqId}`)?.value?.trim();
      } else {
        msg = document.getElementById(`notif-msg-${reqId}`)?.value?.trim();
      }
      if(!msg) return alert("Message required!");
      const snap = await db.ref('users/' + uid + '/fcmToken').once('value');
      const token = snap.val();
      if(!token) return alert("User has not enabled notifications");
      await sendFcmMsg(token, msg);
    };

    // --- Dashboard ---
    function renderDashboard(users) {
      const totalUsers = Object.keys(users || {}).length;
      const totalBalance = Object.values(users || {}).reduce((sum, u) => sum + Number(u.balance || 0), 0);
      const html = `
        <h3>Dashboard</h3>
        <div>‡¶Æ‡ßã‡¶ü ‡¶á‡¶â‡¶ú‡¶æ‡¶∞: <b>${totalUsers}</b></div>
        <div>‡¶Æ‡ßã‡¶ü ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏: <b>${totalBalance.toFixed(2)}</b></div>
      `;
      document.getElementById('dashboard').innerHTML = html;
    }
  </script>
</body>
</html>
